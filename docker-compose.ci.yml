# Docker Compose for CI/CD Environment
# Optimized for automated testing in CI pipelines (GitHub Actions, GitLab CI, Jenkins, etc.)
#
# Key optimizations:
# - No port mappings (internal communication only)
# - Ephemeral storage (tmpfs) for maximum speed
# - Aggressive health check intervals
# - No restart policies
# - Optimized PostgreSQL settings for speed over durability
# - Auto-runs tests and exits with proper status code
#
# Usage:
#   docker compose -f docker-compose.ci.yml up --abort-on-container-exit --exit-code-from app
name: dashtam-ci

services:
  # PostgreSQL Database (CI) - Speed optimized
  postgres:
    image: postgres:17.6-alpine3.22
    container_name: dashtam-ci-postgres
    environment:
      POSTGRES_DB: ${TEST_POSTGRES_DB:-dashtam_test}
      POSTGRES_USER: ${TEST_POSTGRES_USER:-dashtam_test_user}
      POSTGRES_PASSWORD: ${TEST_POSTGRES_PASSWORD:-test_password}
      # Performance optimizations for CI (sacrifices durability for speed)
      POSTGRES_INITDB_ARGS: "-E UTF8 --lc-collate=C --lc-ctype=C"
    # No port mapping - internal only
    tmpfs:
      - /var/lib/postgresql/data
      - /var/run/postgresql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${TEST_POSTGRES_USER:-dashtam_test_user}"]
      interval: 2s
      timeout: 2s
      retries: 10
      start_period: 5s
    networks:
      - dashtam-ci-network
    # CI-specific PostgreSQL configuration for maximum speed
    command: >
      postgres
      -c fsync=off
      -c synchronous_commit=off
      -c full_page_writes=off
      -c random_page_cost=1.0
      -c shared_buffers=256MB
      -c effective_cache_size=512MB
      -c maintenance_work_mem=128MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c max_connections=100

  # Redis Cache (CI) - Ephemeral, no persistence
  redis:
    image: redis:8.2.1-alpine3.22
    container_name: dashtam-ci-redis
    # No port mapping - internal only
    tmpfs:
      - /data
    command: redis-server --appendonly no --save ""
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 2s
      timeout: 2s
      retries: 10
      start_period: 3s
    networks:
      - dashtam-ci-network

  # Main Application (CI) - Runs tests and exits
  app:
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: development
    container_name: dashtam-ci-app
    environment:
      DATABASE_URL: postgresql+asyncpg://${TEST_POSTGRES_USER:-dashtam_test_user}:${TEST_POSTGRES_PASSWORD:-test_password}@postgres:5432/${TEST_POSTGRES_DB:-dashtam_test}
      REDIS_URL: redis://redis:6379/1
      SECRET_KEY: ${SECRET_KEY:-ci-test-secret-key-never-use-in-production}
      ENCRYPTION_KEY: ${ENCRYPTION_KEY:-ci-test-encryption-key-32chars}
      ENVIRONMENT: testing
      LOG_LEVEL: ${LOG_LEVEL:-INFO}  # Changed to INFO for better debugging
      # URLs for internal communication
      API_BASE_URL: http://app:8000  # Added - internal Docker network URL
      CALLBACK_BASE_URL: http://callback:8182  # Added - callback service URL
      # CI-specific settings
      TESTING: "true"
      CI: "true"
      DISABLE_EXTERNAL_CALLS: "true"
      MOCK_PROVIDERS: "true"
      PYTHONUNBUFFERED: "1"
      # Optional: Codecov token can be passed from CI secrets
      CODECOV_TOKEN: ${CODECOV_TOKEN:-}
    # No port mapping - not needed in CI
    volumes:
      - ./src:/app/src:ro
      - ./tests:/app/tests:ro
      - ./alembic:/app/alembic:ro
      - ./.env.ci:/app/.env:ro
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - dashtam-ci-network
    # Run tests and exit with proper status code
    command: >
      sh -c "
        set -e
        echo '=============================================='
        echo 'Dashtam CI/CD Test Environment'
        echo '=============================================='
        echo ''
        echo 'Running test suite...'
        echo ''
        uv run pytest tests/ \
          -v \
          --cov=src \
          --cov-report=xml \
          --cov-report=term-missing \
          --junit-xml=test-results.xml \
          --maxfail=5 || exit 1
        echo ''
        echo '=============================================='
        echo 'All tests passed!'
        echo '=============================================='
      "

  # OAuth Callback Server (CI) - Required for OAuth tests
  callback:
    build:
      context: .
      dockerfile: docker/Dockerfile
      target: callback
    container_name: dashtam-ci-callback
    environment:
      API_BASE_URL: http://app:8000
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    # No port mapping - internal communication only in CI
    volumes:
      - ./certs:/app/certs:ro
    depends_on:
      - app
    networks:
      - dashtam-ci-network
    # Keep running for OAuth callback handling during tests
    # Note: In test environment, we just keep the container alive
    # The actual callback handling is done through the app's routing
    command: >
      sh -c "
        echo 'CI callback server ready for OAuth tests.' &&
        tail -f /dev/null
      "

networks:
  dashtam-ci-network:
    driver: bridge

# No named volumes - everything is ephemeral for CI
# This ensures each run starts with a completely clean state
